from random import randint, random
from sympy import nextprime
from sage.all import *
from sklearn.model_selection import train_test_split

import pandas as pd  ######changed

import sys
sys.set_int_max_str_digits(1000000)  # or a higher number if needed

load("enc_utils_updated.sage")

def sigmoid(z):
    return 1 / (1 + exp(-z))

def logistic_loss_gradient(X, y, w, b):
    m = len(y)
    w = vector(RR, w)
    b = RR(b)
    grad_w = vector(RR, [0.0] * len(w))
    grad_b = 0.0
    for i in range(m):

        xi = vector(RR, X[i])  ######forced vector
        z = w.dot_product(xi) + b
        pred = sigmoid(z)
        error = pred - y[i]
        grad_w += error * xi
        grad_b += error

        grad_w = vector(RR, grad_w)
        grad_b = RR(grad_b)

    w = vector(RR, w)
    b = RR(b)

    return grad_w / m, grad_b / m


def compute_accuracy(X_test, y_test, w, b):
    correct = 0
    for xi, yi in zip(X_test, y_test):
        xi = vector(RR, xi)  ######forced vector
        pred = 1 if sigmoid(w.dot_product(xi) + b) >= 0.5 else 0
        if pred == yi:
            correct += 1
    return correct / len(y_test)


def federated_learning():
    rounds = 10
    local_epochs = 10
    sf = 10                 #############ACCURACY REGULATION
    lam = 330
    m_prime = nextprime(1000*pow(10,2*sf+1))
    m = pow(m_prime,lam)
    d = 30
    
    d1 = pd.read_csv("datalocal1.csv") 
    d2 = pd.read_csv("datalocal2.csv")  
    dtest = pd.read_csv("data_test.csv")  

    X1 = [vector(RR, row[:-1]) for row in d1.values]  
    y1 = [row[-1] for row in d1.values]  

    X2 = [vector(RR, row[:-1]) for row in d2.values] 
    y2 = [row[-1] for row in d2.values]  

    X_test = [vector(RR, row[:-1]) for row in dtest.values]
    y_test = [row[-1] for row in dtest.values] 
    
    c1 = len(X1)
    c2 = len(X2)
    total = c1+c2
    c1 = c1/total
    c2 = c2/total

    w_global = vector(RR, [10] * len(X1[0]))   
    b_global = 0.0

    d_ext = d * (d + 1) // 2
    
    s = secret_key_generation(d, m)
    s_inv = inv_secret_key_generation(s, m)
    
    #generated by client 1
    s1 = secret_key_generation(d, m)
    s1_inv = inv_secret_key_generation(s1, m)
   
    
    s1_ext =  matrix(generate_extended_key(s1, m))
    s1_ext_inv = inv_secret_key_generation(s1_ext, m)
    
    # Matrices generation     
    M1_ext_s = generate_public_matrix(s1_ext_inv, s_inv, m, m_prime, d, d_ext) #switch from s1_ext1 -> s
    M1_s_s1 = generate_public_matrix(s_inv, s1_inv, m, m_prime, d, d) #switch from s -> s1
    
    #generated by client 2
    s2 = secret_key_generation(d, m)
    s2_inv = inv_secret_key_generation(s2, m)
    
    s2_ext =  matrix(generate_extended_key(s2, m))
    s2_ext_inv = inv_secret_key_generation(s2_ext, m)
    
    # Matrices generation
    M2_ext_s = generate_public_matrix(s2_ext_inv, s_inv, m, m_prime, d, d_ext) #switch from s2_ext1 -> s
    M2_s_s2 = generate_public_matrix(s_inv, s2_inv, m, m_prime, d, d) #switch from s -> s2
     
      
    
    for r in range(rounds):
        print("\nRound", r+1)

        # Client 1
        w1 = w_global[:] 
        b1 = b_global
        
        for _ in range(local_epochs):
            grad_w1, grad_b1 = logistic_loss_gradient(X1, y1, w1, b1)
            w1 -= 0.1 * grad_w1
            b1 -= 0.1 * grad_b1
        
        
        #client 1 encrypts weights and biases using s1 
        w1_enc_s1 = encrypt_values(w1, sf, m, m_prime, d, s1) # w1 encrypted with s1
        c1_enc_s1 = encrypt_value(c1, sf, m, m_prime, d, s1)
        b1_enc_s1 = encrypt_value(b1, sf, m, m_prime, d, s1)
   
        
        # Client 2
        w2 = w_global[:] 
        b2 = b_global

        for _ in range(local_epochs):
            grad_w2, grad_b2 = logistic_loss_gradient(X2, y2, w2, b2)
            w2 -= 0.1 * grad_w2
            b2 -= 0.1 * grad_b2
        
        # Print plaintext aggregated weights before encryption -----
        w_avg = w1 * c1 + w2 * c2
        b_avg  = b1 * c1 + b2 * c2

        print('w before encryption:', w_avg)
        print('b before encryption:', b_avg)
       
       
        #client 2 encrypts weights and biases using s2 
        w2_enc_s2 = encrypt_values(w2, sf, m, m_prime, d, s2) 
        c2_enc_s2 = encrypt_value(c2, sf, m, m_prime, d, s2)
        b2_enc_s2 = encrypt_value(b2, sf, m, m_prime, d, s2)
         
        
        #server side. Server has M1_ext_s, M1_s_s1, M2_ext_s, M2_s_s2 sent by clients
        
        c1_enc_s1_dup = duplicate_cipher_row(c1_enc_s1, d)
        c2_enc_s2_dup = duplicate_cipher_row(c2_enc_s2, d)
        
        
        # multiplication of encrypted weights and encrypted coefs (d_ext)
        w1c1_enc_s1_ext = cipher_multiplication_matrixwise(w1_enc_s1, c1_enc_s1_dup, Index)
        b1c1_enc_s1_ext = cipher_multiplication_matrixwise(b1_enc_s1, c1_enc_s1, Index)
        w2c2_enc_s2_ext = cipher_multiplication_matrixwise(w2_enc_s2, c2_enc_s2_dup, Index)
        b2c2_enc_s2_ext = cipher_multiplication_matrixwise(b2_enc_s2, c2_enc_s2, Index)
        
        #switch from s1_ext to s
        w1c1_enc_s1_s = (M1_ext_s * w1c1_enc_s1_ext.transpose()).transpose()
        b1c1_enc_s1_s = (M1_ext_s * b1c1_enc_s1_ext.transpose()).transpose()
        
        #switch from s2_ext to s
        w2c2_enc_s2_s = (M2_ext_s * w2c2_enc_s2_ext.transpose()).transpose()
        b2c2_enc_s2_s = (M2_ext_s * b2c2_enc_s2_ext.transpose()).transpose()
        
        #aggregate weights
        w_agg_s = w1c1_enc_s1_s + w2c2_enc_s2_s
        b_agg_s = b1c1_enc_s1_s +  b2c2_enc_s2_s
        
        #switch from s to s1
        w_agg_s1 = (M1_s_s1 * w_agg_s.transpose()).transpose()
        b_agg_s1 = (M1_s_s1 * b_agg_s.transpose()).transpose()
        
        #switch from s to s2
        w_agg_s2 = (M2_s_s2 * w_agg_s.transpose()).transpose()
        b_agg_s2 = (M2_s_s2 * b_agg_s.transpose()).transpose()
        
        
        #decrypt with s1       
        w_dec_s1 = decrypt_values(w_agg_s1, 2*sf, m_prime, d, s1_inv) 
        b_dec_s1 = decrypt_value(b_agg_s1, 2*sf, m_prime, d, s1_inv)
        
        #decrypt with s2
        w_dec_s2 = decrypt_values(w_agg_s2, 2*sf, m_prime, d, s2_inv) 
        b_dec_s2 = decrypt_value(b_agg_s2, 2*sf, m_prime, d, s2_inv)
        
        
        
        print("Decrypted weights Client1:", w_dec_s1)
        print("Decrypted bias Client1:", b_dec_s1)
        
        print("Decrypted weights Client2:", w_dec_s2)
        print("Decrypted bias Client2:", b_dec_s2)
        
        w_dec = w_dec_s1
        b_dec = b_dec_s1
        
        w_global = vector(RR, w_dec)
        b_global = b_dec

        
    acc = compute_accuracy(X_test, y_test, w_global, b_global)
    print("\nTest Accuracy:", round(acc * 100, 2), "%")

federated_learning()
